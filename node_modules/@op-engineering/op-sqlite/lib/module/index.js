// import NativeOPSQLite from './NativeOPSQLite';
import { NativeModules } from 'react-native';
if (global.__OPSQLiteProxy == null) {
  if (NativeModules.OPSQLite == null) {
    throw new Error('Base module not found. Maybe try rebuilding the app.');
  }
  if (NativeModules.OPSQLite.install == null) {
    throw new Error('Failed to install op-sqlite: React Native is not running on-device. OPSQLite can only be used when synchronous method invocations (JSI) are possible. If you are using a remote debugger (e.g. Chrome), switch to an on-device debugger (e.g. Flipper) instead.');
  }

  // Call the synchronous blocking install() function
  const result = NativeModules.OPSQLite.install();
  if (result !== true) {
    throw new Error(`Failed to install op-sqlite: The native OPSQLite Module could not be installed! Looks like something went wrong when installing JSI bindings, check the native logs for more info`);
  }

  // Check again if the constructor now exists. If not, throw an error.
  if (global.__OPSQLiteProxy == null) {
    throw new Error('Failed to install op-sqlite, the native initializer function does not exist. Are you trying to use OPSQLite from different JS Runtimes?');
  }
}
const proxy = global.__OPSQLiteProxy;
export const OPSQLite = proxy;
export const {
  IOS_DOCUMENT_PATH,
  IOS_LIBRARY_PATH,
  ANDROID_DATABASE_PATH,
  ANDROID_FILES_PATH,
  ANDROID_EXTERNAL_FILES_PATH
} = !!NativeModules.OPSQLite.getConstants ? NativeModules.OPSQLite.getConstants() : NativeModules.OPSQLite;

/**
 * Object returned by SQL Query executions {
 *  insertId: Represent the auto-generated row id if applicable
 *  rowsAffected: Number of affected rows if result of a update query
 *  message: if status === 1, here you will find error description
 *  rows: if status is undefined or 0 this object will contain the query results
 * }
 *
 * @interface QueryResult
 */

/**
 * Column metadata
 * Describes some information about columns fetched by the query
 */

/**
 * Allows the execution of bulk of sql commands
 * inside a transaction
 * If a single query must be executed many times with different arguments, its preferred
 * to declare it a single time, and use an array of array parameters.
 */

/**
 * status: 0 or undefined for correct execution, 1 for error
 * message: if status === 1, here you will find error description
 * rowsAffected: Number of affected rows if status == 0
 */

/**
 * Result of loading a file and executing every line as a SQL command
 * Similar to BatchQueryResult
 */

const locks = {};

// Enhance some host functions

// Add 'item' function to result object to allow the sqlite-storage typeorm driver to work
function enhanceQueryResult(result) {
  // Add 'item' function to result object to allow the sqlite-storage typeorm driver to work
  if (result.rows == null) {
    result.rows = {
      _array: [],
      length: 0,
      item: idx => result.rows?._array[idx]
    };
  } else {
    result.rows.item = idx => result.rows?._array[idx];
  }
}
const _open = OPSQLite.open;
OPSQLite.open = options => {
  _open(options);
  locks[options.name] = {
    queue: [],
    inProgress: false
  };
};
const _close = OPSQLite.close;
OPSQLite.close = dbName => {
  _close(dbName);
  delete locks[dbName];
};
const _execute = OPSQLite.execute;
OPSQLite.execute = (dbName, query, params) => {
  const sanitizedParams = params?.map(p => {
    if (ArrayBuffer.isView(p)) {
      return p.buffer;
    }
    return p;
  });
  const result = _execute(dbName, query, sanitizedParams);
  enhanceQueryResult(result);
  return result;
};
const _executeAsync = OPSQLite.executeAsync;
OPSQLite.executeAsync = async (dbName, query, params) => {
  const sanitizedParams = params?.map(p => {
    if (ArrayBuffer.isView(p)) {
      return p.buffer;
    }
    return p;
  });
  const res = await _executeAsync(dbName, query, sanitizedParams);
  enhanceQueryResult(res);
  return res;
};
const _prepareStatement = OPSQLite.prepareStatement;
OPSQLite.prepareStatement = (dbName, query) => {
  const stmt = _prepareStatement(dbName, query);
  return {
    bind: params => {
      const sanitizedParams = params.map(p => {
        if (ArrayBuffer.isView(p)) {
          return p.buffer;
        }
        return p;
      });
      stmt.bind(sanitizedParams);
    },
    execute: () => {
      const res = stmt.execute();
      enhanceQueryResult(res);
      return res;
    }
  };
};
OPSQLite.transaction = async (dbName, fn) => {
  if (!locks[dbName]) {
    throw Error(`SQLite Error: No lock found on db: ${dbName}`);
  }
  let isFinalized = false;

  // Local transaction context object implementation
  const execute = (query, params) => {
    if (isFinalized) {
      throw Error(`SQLite Error: Cannot execute query on finalized transaction: ${dbName}`);
    }
    return OPSQLite.execute(dbName, query, params);
  };
  const executeAsync = (query, params) => {
    if (isFinalized) {
      throw Error(`SQLite Error: Cannot execute query on finalized transaction: ${dbName}`);
    }
    return OPSQLite.executeAsync(dbName, query, params);
  };
  const commit = () => {
    if (isFinalized) {
      throw Error(`SQLite Error: Cannot execute commit on finalized transaction: ${dbName}`);
    }
    const result = OPSQLite.execute(dbName, 'COMMIT');
    isFinalized = true;
    return result;
  };
  const rollback = () => {
    if (isFinalized) {
      throw Error(`SQLite Error: Cannot execute rollback on finalized transaction: ${dbName}`);
    }
    const result = OPSQLite.execute(dbName, 'ROLLBACK');
    isFinalized = true;
    return result;
  };
  async function run() {
    try {
      await OPSQLite.executeAsync(dbName, 'BEGIN TRANSACTION');
      await fn({
        commit,
        execute,
        executeAsync,
        rollback
      });
      if (!isFinalized) {
        commit();
      }
    } catch (executionError) {
      if (!isFinalized) {
        try {
          rollback();
        } catch (rollbackError) {
          throw rollbackError;
        }
      }
      throw executionError;
    } finally {
      locks[dbName].inProgress = false;
      isFinalized = false;
      startNextTransaction(dbName);
    }
  }
  return await new Promise((resolve, reject) => {
    const tx = {
      start: () => {
        run().then(resolve).catch(reject);
      }
    };
    locks[dbName].queue.push(tx);
    startNextTransaction(dbName);
  });
};
const startNextTransaction = dbName => {
  if (!locks[dbName]) {
    throw Error(`Lock not found for db: ${dbName}`);
  }
  if (locks[dbName].inProgress) {
    // Transaction is already in process bail out
    return;
  }
  if (locks[dbName].queue.length) {
    locks[dbName].inProgress = true;
    const tx = locks[dbName].queue.shift();
    if (!tx) {
      throw new Error('Could not get a operation on datebase');
    }
    setImmediate(() => {
      tx.start();
    });
  }
};
export const open = options => {
  OPSQLite.open(options);
  return {
    close: () => OPSQLite.close(options.name),
    delete: () => OPSQLite.delete(options.name, options.location),
    attach: (dbNameToAttach, alias, location) => OPSQLite.attach(options.name, dbNameToAttach, alias, location),
    detach: alias => OPSQLite.detach(options.name, alias),
    transaction: fn => OPSQLite.transaction(options.name, fn),
    execute: (query, params) => OPSQLite.execute(options.name, query, params),
    executeAsync: (query, params) => OPSQLite.executeAsync(options.name, query, params),
    executeBatch: commands => OPSQLite.executeBatch(options.name, commands),
    executeBatchAsync: commands => OPSQLite.executeBatchAsync(options.name, commands),
    loadFile: location => OPSQLite.loadFile(options.name, location),
    updateHook: callback => OPSQLite.updateHook(options.name, callback),
    commitHook: callback => OPSQLite.commitHook(options.name, callback),
    rollbackHook: callback => OPSQLite.rollbackHook(options.name, callback),
    prepareStatement: query => OPSQLite.prepareStatement(options.name, query),
    loadExtension: (path, entryPoint) => OPSQLite.loadExtension(options.name, path, entryPoint),
    executeRawAsync: (query, params) => OPSQLite.executeRawAsync(options.name, query, params),
    getDbPath: () => OPSQLite.getDbPath(options.name, options.location)
  };
};
export const moveAssetsDatabase = args => {
  return NativeModules.OPSQLite.moveAssetsDatabase(args);
};
export const isSQLCipher = () => {
  return OPSQLite.isSQLCipher();
};
//# sourceMappingURL=index.js.map