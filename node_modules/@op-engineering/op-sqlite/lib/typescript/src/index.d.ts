declare global {
    function nativeCallSyncHook(): unknown;
    var __OPSQLiteProxy: object | undefined;
}
export declare const OPSQLite: ISQLite;
export declare const IOS_DOCUMENT_PATH: any, IOS_LIBRARY_PATH: any, ANDROID_DATABASE_PATH: any, ANDROID_FILES_PATH: any, ANDROID_EXTERNAL_FILES_PATH: any;
/**
 * Object returned by SQL Query executions {
 *  insertId: Represent the auto-generated row id if applicable
 *  rowsAffected: Number of affected rows if result of a update query
 *  message: if status === 1, here you will find error description
 *  rows: if status is undefined or 0 this object will contain the query results
 * }
 *
 * @interface QueryResult
 */
export type QueryResult = {
    insertId?: number;
    rowsAffected: number;
    rows?: {
        /** Raw array with all dataset */
        _array: any[];
        /** The lengh of the dataset */
        length: number;
        /** A convenience function to acess the index based the row object
         * @param idx the row index
         * @returns the row structure identified by column names
         */
        item: (idx: number) => any;
    };
    /**
     * Query metadata, avaliable only for select query results
     */
    metadata?: ColumnMetadata[];
};
/**
 * Column metadata
 * Describes some information about columns fetched by the query
 */
export type ColumnMetadata = {
    /** The name used for this column for this resultset */
    name: string;
    /** The declared column type for this column, when fetched directly from a table or a View resulting from a table column. "UNKNOWN" for dynamic values, like function returned ones. */
    type: string;
    /**
     * The index for this column for this resultset*/
    index: number;
};
/**
 * Allows the execution of bulk of sql commands
 * inside a transaction
 * If a single query must be executed many times with different arguments, its preferred
 * to declare it a single time, and use an array of array parameters.
 */
export type SQLBatchTuple = [string] | [string, Array<any> | Array<Array<any>>];
export type UpdateHookOperation = 'INSERT' | 'DELETE' | 'UPDATE';
/**
 * status: 0 or undefined for correct execution, 1 for error
 * message: if status === 1, here you will find error description
 * rowsAffected: Number of affected rows if status == 0
 */
export type BatchQueryResult = {
    rowsAffected?: number;
};
/**
 * Result of loading a file and executing every line as a SQL command
 * Similar to BatchQueryResult
 */
export interface FileLoadResult extends BatchQueryResult {
    commands?: number;
}
export interface Transaction {
    commit: () => QueryResult;
    execute: (query: string, params?: any[]) => QueryResult;
    executeAsync: (query: string, params?: any[] | undefined) => Promise<QueryResult>;
    rollback: () => QueryResult;
}
export interface PendingTransaction {
    start: () => void;
}
export type PreparedStatementObj = {
    bind: (params: any[]) => void;
    execute: () => QueryResult;
};
interface ISQLite {
    open: (options: {
        name: string;
        location?: string;
        encryptionKey?: string;
    }) => void;
    close: (dbName: string) => void;
    delete: (dbName: string, location?: string) => void;
    attach: (mainDbName: string, dbNameToAttach: string, alias: string, location?: string) => void;
    detach: (mainDbName: string, alias: string) => void;
    transaction: (dbName: string, fn: (tx: Transaction) => Promise<void>) => Promise<void>;
    execute: (dbName: string, query: string, params?: any[]) => QueryResult;
    executeAsync: (dbName: string, query: string, params?: any[]) => Promise<QueryResult>;
    executeBatch: (dbName: string, commands: SQLBatchTuple[]) => BatchQueryResult;
    executeBatchAsync: (dbName: string, commands: SQLBatchTuple[]) => Promise<BatchQueryResult>;
    loadFile: (dbName: string, location: string) => Promise<FileLoadResult>;
    updateHook: (dbName: string, callback?: ((params: {
        table: string;
        operation: UpdateHookOperation;
        row?: any;
        rowId: number;
    }) => void) | null) => void;
    commitHook: (dbName: string, callback?: (() => void) | null) => void;
    rollbackHook: (dbName: string, callback?: (() => void) | null) => void;
    prepareStatement: (dbName: string, query: string) => PreparedStatementObj;
    loadExtension: (dbName: string, path: string, entryPoint?: string) => void;
    executeRawAsync: (dbName: string, query: string, params?: any[]) => Promise<any[]>;
    getDbPath: (dbName: string, location?: string) => string;
    isSQLCipher: () => boolean;
}
export type OPSQLiteConnection = {
    close: () => void;
    delete: () => void;
    attach: (dbNameToAttach: string, alias: string, location?: string) => void;
    detach: (alias: string) => void;
    transaction: (fn: (tx: Transaction) => Promise<void>) => Promise<void>;
    execute: (query: string, params?: any[]) => QueryResult;
    executeAsync: (query: string, params?: any[]) => Promise<QueryResult>;
    executeBatch: (commands: SQLBatchTuple[]) => BatchQueryResult;
    executeBatchAsync: (commands: SQLBatchTuple[]) => Promise<BatchQueryResult>;
    loadFile: (location: string) => Promise<FileLoadResult>;
    updateHook: (callback: ((params: {
        table: string;
        operation: UpdateHookOperation;
        row?: any;
        rowId: number;
    }) => void) | null) => void;
    commitHook: (callback: (() => void) | null) => void;
    rollbackHook: (callback: (() => void) | null) => void;
    prepareStatement: (query: string) => PreparedStatementObj;
    loadExtension: (path: string, entryPoint?: string) => void;
    executeRawAsync: (query: string, params?: any[]) => Promise<any[]>;
    getDbPath: () => string;
};
export declare const open: (options: {
    name: string;
    location?: string;
    encryptionKey?: string;
}) => OPSQLiteConnection;
export declare const moveAssetsDatabase: (args: {
    filename: string;
    path?: string;
    overwrite?: boolean;
}) => boolean;
export declare const isSQLCipher: () => boolean;
export {};
//# sourceMappingURL=index.d.ts.map